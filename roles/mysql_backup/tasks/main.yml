---
- name: Clean the backup root path before starting the routine
  file:
    state: absent
    path: "{{ mysql_artifact_path }}/"
  when: MYSQL_BACKUP_PRE_CLEAN_ROOT and mysql_artifact_path is defined and mysql_artifact_path != "" and
        MYSQL_BACKUP_STORAGE_OPTIONS.EXTERNAL_STORAGE_TYPE != ""

- name: Create backup directory
  file:
    path: "{{ MYSQL_BACKUP_LOCATION }}"
    state: directory

- name: Check if current MySQL backup already exists
  stat:
    path: "{{ MYSQL_BACKUP_LOCATION }}/{{ MYSQL_BACKUP_DATE }}_mysql.sql.gz"
    get_checksum: false
    get_md5: false
  register: mysql_backup_status

- name: Create MySQL database backup
  shell: "mysqldump -u root -p{{ MYSQL_ADMIN_PASSWORD }} --add-drop-database --skip-lock-tables edxapp > {{ MYSQL_BACKUP_LOCATION }}/{{ MYSQL_BACKUP_DATE }}_mysql.sql"
  args:
    chdir: "{{ MYSQL_BACKUP_LOCATION }}"
  when: mysql_backup_status.stat.exists == False

- name: Compress mysql backup file
  shell: "gzip {{ MYSQL_BACKUP_LOCATION }}/{{ MYSQL_BACKUP_DATE }}_mysql.sql"
  args:
    chdir: "{{ MYSQL_BACKUP_LOCATION}}"
  when: mysql_backup_status.stat.exists == False

- name: Give the server time to recover
  pause:
    minutes: 1
    prompt: Pausing to give the server time to recover
  when: mysql_backup_status.stat.exists == False

- name: Execute the storage of the backup
  include_role:
    name: storage_backups
  vars:
    STORAGE_BACKUPS_OPTIONS: "{{ MYSQL_BACKUP_STORAGE_OPTIONS }}"
    STORAGE_BACKUPS_FILES_TO_UPLOAD:
      - "{{ MYSQL_BACKUP_LOCATION }}/{{ MYSQL_BACKUP_DATE }}_mysql.sql.gz"
    STORAGE_BACKUPS_FOLDER:
      - "mysql"

- name: Clean artifact path
  file:
    state: absent
    path: "{{ mysql_artifact_path }}/"
  when: mysql_artifact_path is defined and mysql_artifact_path != "" and
        MYSQL_BACKUP_STORAGE_OPTIONS.EXTERNAL_STORAGE_TYPE != ""
